<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My first Three.js app</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>

<script src="build/three.js"></script>

<!--Shaders and post processing filters-->
<script src="js/shaders/ConvolutionShader.js"></script>
<script src="js/shaders/CopyShader.js"></script>
<script src="js/shaders/FXAAShader.js"></script>

<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/postprocessing/BloomPass.js"></script>
<script src='js/Perlin.js'></script>




<script>
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

    var effectFXAA;



    var renderer = new THREE.WebGLRenderer({antialias: false });
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.autoClear = false;


    document.body.appendChild( renderer.domElement );


    var global_scalar = 0.2

    var mtg = function(posx, posy, scalar,uppy) {
        // Think of this as a triangle object.
        this.triangleGeometry = new THREE.Geometry();
        var initial_displacement = new THREE.Vector3(posx, posy, 0);
        if(uppy == true) {
            this.v1 = new THREE.Vector3(0 + posx, 0 + posy, 0);
            this.v2 = new THREE.Vector3(2 + posx, 0 + posy, 0);
            this.v3 = new THREE.Vector3(1 + posx, Math.sqrt(3) + posy, 0);
        }
        else
        {
//        this.v1 = new THREE.Vector3(posx, posy + Math.sqrt(3), 0);
//        this.v2 = new THREE.Vector3(posx + 1, 0 + posy, 0);
//        this.v3 = new THREE.Vector3(2 + posx, posy + Math.sqrt(3), 0);

        this.v1 = new THREE.Vector3(posx, posy, 0);
        this.v2 = new THREE.Vector3(posx + 1, 0 + posy-Math.sqrt(3), 0);
        this.v3 = new THREE.Vector3(2 + posx, posy, 0);


        }

//
//        this.v1 = new THREE.Vector3(0 + posx, Math.sqrt(3) + posy, 0);
//                this.v2 = new THREE.Vector3(2 + posx, Math.sqrt(3) + posy, 0);
//                this.v3 = new THREE.Vector3(1 + posx, 0 + posy, 0);
//        }
        this.material = new THREE.MeshBasicMaterial({color:0xFFD54F});

        console.log(this.v1);
        this.v1.multiplyScalar(scalar);
        this.v2.multiplyScalar(scalar);
        this.v3.multiplyScalar(scalar);

        this.triangleGeometry.vertices.push(this.v1);
        this.triangleGeometry.vertices.push(this.v2);
        this.triangleGeometry.vertices.push(this.v3);

        this.triangleGeometry.faces.push(new THREE.Face3(0,1,2));
        this.mesh = new THREE.Mesh(this.triangleGeometry, this.material);
    }




//    var o1 = new mtg(-4,2,global_scalar);
//    var o2 = new mtg(-2,2,global_scalar);
//    var o3 = new mtg( 0,2,global_scalar);
//
//
//    scene.add(o1.mesh);
//    scene.add(o2.mesh);
//    scene.add(o3.mesh);

    var width_of_triangles;
    var width_of_screen;

    var number_of_x_slots = 40;
    var number_of_y_slots = 50;

    var chose_one = new THREE.MeshBasicMaterial();

    for (var y = 0 ; y < number_of_y_slots; y++)
    {
        for (var x = 0 ; x < number_of_x_slots; x++)
        {

            var bias = y%2;
            var other_bias = x%2;

            var o1 = new mtg(2*x - 40 + bias, (y - 12) *Math.sqrt(3) , global_scalar, other_bias);
            var o2 = new mtg(2*x - 40 + bias, (y - 12) *Math.sqrt(3) , global_scalar, !other_bias);


            if (x==5 && y==10)
            {chose_one = o1;

                o1.mesh = new THREE.Mesh(o1.triangleGeometry, new THREE.MeshBasicMaterial({color:0xff0000}));

            }
                scene.add(o1.mesh);
                scene.add(o2.mesh);

        }

    }



    camera.position.z = 5;

    var renderModel = new THREE.RenderPass( scene, camera );
    var effectBloom = new THREE.BloomPass( 1.3 );
    var effectCopy = new THREE.ShaderPass( THREE.CopyShader );

    effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );

    var width = window.innerWidth || 2;
    var height = window.innerHeight || 2;


    effectFXAA.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );

    effectCopy.renderToScreen = true;

    composer = new THREE.EffectComposer( renderer );

    composer.addPass( renderModel );
    composer.addPass( effectFXAA );
    composer.addPass( effectBloom );
    composer.addPass( effectCopy );




























    var render = function () {
        requestAnimationFrame( render );
//        renderer.render(scene, camera);
        renderer.clear();
        composer.render();
    };
    render();
</script>



</body>
</html>